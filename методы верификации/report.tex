\documentclass[utf8,14pt,a4paper,oneside,russian]{book}
\usepackage[14pt]{extsizes}
\usepackage{longtable}
\usepackage{listings}
\usepackage{mathtools}

%===========
%=Кодировка=
%===========
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[main=russian, english]{babel}

%===================
%=Разметка страницы=
%===================
\usepackage[left=3cm, right=1cm, top=2cm, bottom=2cm, headheight=14pt, headsep=1cm, footskip=1cm]{geometry}
\pagestyle{plain}
\linespread{1.1} %Межстрочный интервад
\setlength{\parindent}{1.25cm} %Абзацный отступ
\setlength{\parskip}{0em} %Интервал между абзацами
\usepackage{indentfirst}

\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath, amssymb, amsfonts}

%===========
%=Заголовки=
%===========
\usepackage{titlesec}

\titleformat{\section}{\centering\large\bfseries}{\thesection.}{0.5em}{\MakeUppercase}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.~#1}}
\titlespacing*{\section}{0em}{2em}{1em}

\titleformat{\subsection}{\centering\normalsize\bfseries}{\thesubsection.}{0.5em}{}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\titlespacing*{\subsection}{0em}{1.25em}{0.5em}

\titlespacing*{\paragraph}{0em}{1.05em}{0.25em}

%============
%=Содержание=
%============
\usepackage{titletoc}
\makeatletter
\renewcommand{\tableofcontents}{\section*{Содержание}\markboth{Содержание}{}\@starttoc{toc}\newpage}
\makeatother
\titlecontents{section}[1.5em]{}{\contentslabel[\thecontentslabel.]{1.5em}}{}{\rule{0.1cm}{0pt}\titlerule*[0.75pc]{.}\contentspage}
\titlecontents{subsection}[4em]{\vspace{0.05em}}{\contentslabel[\thecontentslabel.]{2em}}{}{\rule{0.1cm}{0pt}\titlerule*[0.75pc]{.}\contentspage}

%========
%=Списки=
%========
\usepackage{enumitem}
\makeatletter
\AddEnumerateCounter{\asbuk}{\@asbuk}{м)}
\makeatother
\setlist{nolistsep, topsep=0.375em}
\setenumerate{leftmargin=2cm, labelsep=0em, labelwidth=0.75cm, align=left}
\setitemize{leftmargin=2cm, labelsep=0em, labelwidth=0.75cm, align=left}
\renewcommand{\labelitemi}{--}
\renewcommand{\labelenumi}{\arabic{enumi})}
\renewcommand{\labelenumii}{\asbuk{enumii})}
\renewcommand{\labelenumiii}{--}

%==========================
%=Математические операторы=
%==========================
\DeclareMathOperator{\mob}{Mob}
\DeclareMathOperator{\fix}{Fix}
\DeclareMathOperator{\ord}{ord}

\graphicspath{{pictures/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\begin{document}

\thispagestyle{empty}
\small
\begin{center}
    \includegraphics[width=4.55cm]{logo_mirea}\\
    \MakeUppercase{Минобрнауки России}\\[1em]
    Федеральное государственное бюджетное образовательное учреждение\\
    высшего образования\\[0.5em]
    \textbf{<<МИРЭА -- Российский технологический университет>>}\\
    \textbf{РТУ МИРЭА}\\
    \rule{\textwidth}{0.75pt}\\
    Институт Искусственного Интеллекта\\
    Базовая кафедра БК252 - информационной безопасности.\\
    
    \rule{\textwidth}{0.75pt}\\[5em]
    \normalsize\MakeUppercase{\textbf{Практическая работа}}\small\\[0.5em]
    По дисциплине\\ <<Методы верификации>>\\[1.5em]
    Тема практической работы\\ \textbf{<<Методы динамического анализа программного обеспечения.>>} \\[3em]
    \begin{tabular}{p{7cm}p{6cm}c}
      Студенты группы ККСО-03-19       & Николенко В.О.                                          \\
                                       & Воеводин К.А.                                            \\
                                       &                                                         \\
      Руководитель практической работы & Коробов Д. В. & \rule{2cm}{0.75pt}                    \\[-0.5em]
                                       &                 & \footnotesize\textit{(подпись)}\small \\[5em]
    \end{tabular}
    \vfill
    Москва -- 2023
  \end{center}
  \normalsize
  \newpage
  
  % Содержание
  \tableofcontents
  
  
  \section{Введение}
  Методы динамического анализа программного обеспечения \\
  (Dynamic Software Analysis) позволяют изучать поведение 
  программы во время ее выполнения. Эти методы используются 
  для тестирования, отладки, профилирования и обнаружения ошибок 
  в программном обеспечении.
  
  
  
  
  \newpage
  \section{Теория}
  
  \subsection{Виды динамического анализа.}
  
  Существует несколько методов динамического анализа программного обеспечения:

  1. Тестирование черного ящика (Black Box Testing) - метод, при котором программа тестируется без знания ее внутренней структуры. Тестирование черного ящика может быть автоматизировано с помощью специальных инструментов, которые генерируют тестовые данные и анализируют результаты выполнения программы.

2. Тестирование белого ящика (White Box Testing) - метод, при котором программа тестируется с знанием ее внутренней структуры. Тестирование белого ящика может быть автоматизировано с помощью инструментов, которые анализируют код программы и генерируют тестовые данные на основе этого анализа.

3. Профилирование (Profiling) - метод, при котором изучается поведение программы во время ее выполнения с целью определения узких мест и оптимизации производительности. Профилирование может быть автоматизировано с помощью специальных инструментов, которые анализируют производительность программы и выдают отчеты о ее работе.

4. Мониторинг (Monitoring) - метод, при котором изучается поведение программы в реальном времени с целью обнаружения ошибок и проблем. Мониторинг может быть автоматизирован с помощью инструментов, которые анализируют данные, получаемые во время выполнения программы, и выдают предупреждения о возможных проблемах.

5. Дебаггинг (Debugging) - метод, при котором изучается поведение программы во время ее выполнения с целью обнаружения и исправления ошибок. Дебаггинг может быть автоматизирован с помощью инструментов, которые позволяют отслеживать выполнение программы и находить места, где происходят ошибки.

Каждый из методов динамического анализа программного обеспечения имеет свои преимущества и недостатки, и выбор метода зависит от конкретной задачи, которую нужно решить.
  
\newpage
\subsection{Тестирование чёрного ящика.}

Тестирование черного ящика проводится без знания внутренней структуры программы. Для этого используются различные методы, такие как функциональное тестирование, тестирование граничных значений, тестирование случайных значений и др. 

Функциональное тестирование проверяет соответствие функциональных требований программы. Например, если программа должна складывать два числа, то функциональное тестирование проверит, что программа действительно складывает два числа и выдает правильный результат.

Тестирование граничных значений проверяет поведение программы на крайних значениях входных данных. Например, если программа должна обрабатывать числа от 1 до 100, то тестирование граничных значений проверит поведение программы при вводе чисел 1 и 100.

Тестирование случайных значений проверяет поведение программы на случайных входных данных. Для этого используются специальные инструменты, которые генерируют случайные входные данные и анализируют результаты выполнения программы.

При проведении тестирования черного ящика также используются различные методы оценки покрытия кода тестами, такие как покрытие строк кода, покрытие ветвей и др. Оценка покрытия кода тестами позволяет определить, какие части программы были протестированы, а какие нет.

\subsection{Тестирование белого ящика.}

Тестирование белого ящика проводится с знанием внутренней структуры программы. Для этого используются различные методы, такие как тестирование модульности, тестирование интеграции, тестирование производительности и др.

Тестирование модульности проверяет корректность работы отдельных модулей программы. Например, если программа состоит из нескольких функций, то тестирование модульности проверит корректность работы каждой функции отдельно.

Тестирование интеграции проверяет корректность работы программы в целом при взаимодействии отдельных модулей. Например, если программа состоит из нескольких функций, то тестирование интеграции проверит корректность работы программы при вызове этих функций в определенном порядке.

Тестирование производительности проверяет скорость работы программы и ее способность обрабатывать большое количество данных. Например, если программа должна обрабатывать большой объем данных, то тестирование производительности проверит, насколько быстро программа обрабатывает эти данные.

При проведении тестирования белого ящика также используются различные методы оценки покрытия кода тестами, такие как покрытие ветвей, покрытие условий и др. Оценка покрытия кода тестами позволяет определить, какие части программы были протестированы, а какие нет, и помогает выявить ошибки в коде программы.

\subsection{Профилирование.}

Профилирование - это процесс анализа работы программы с целью выявления узких мест и оптимизации ее работы. Профилирование может проводиться как на этапе разработки программы, так и после ее выпуска.

Профилирование проводится с помощью специальных инструментов - профайлеров. Профайлеры могут быть интегрированы в IDE или работать как отдельные приложения.

Процесс профилирования состоит из нескольких этапов:

1. Подготовка тестовых данных и сценариев работы программы.

2. Запуск профайлера и подключение его к программе.

3. Выполнение тестовых сценариев и сбор информации о работе программы.

4. Анализ полученных данных и выявление узких мест.

5. Оптимизация работы программы на основе полученных результатов.

В процессе профилирования могут использоваться различные методы анализа, такие как анализ времени выполнения функций, анализ использования памяти, анализ вызовов функций и др.

После проведения профилирования может быть создан отчет, в котором будут отражены результаты анализа работы программы и рекомендации по ее оптимизации.

\subsection{Мониторинг.}
Мониторинг - это процесс наблюдения за работой системы с целью выявления проблем и предотвращения возможных сбоев. Мониторинг может проводиться как на этапе разработки системы, так и после ее запуска.

Мониторинг может проводиться с помощью различных инструментов, таких как мониторы ресурсов, системы журналирования, мониторы производительности и др.

Процесс мониторинга состоит из нескольких этапов:

1. Определение целей мониторинга и выбор инструментов для его проведения.
2. Установка и настройка мониторинговых инструментов.
3. Сбор информации о работе системы, включая данные о производительности, использовании ресурсов и др.
4. Анализ полученных данных и выявление проблем и узких мест.
5. Принятие мер по устранению проблем и оптимизации работы системы.

В процессе мониторинга могут использоваться различные методы анализа, такие как анализ журналов событий, анализ производительности, анализ использования ресурсов и др.

После проведения мониторинга может быть создан отчет, в котором будут отражены результаты анализа работы системы и рекомендации по ее улучшению.

\subsection{Дебаггинг.}

Дебаггинг - это процесс поиска и устранения ошибок в программном коде. Для проведения дебаггинга могут использоваться различные инструменты, такие как отладчики, логирование и тестирование.

Процесс дебаггинга состоит из нескольких этапов:

1. Выявление проблемы. Этот этап может включать анализ сообщений об ошибках, журналов событий и других данных.

2. Воспроизведение проблемы. Необходимо повторить условия, при которых возникает ошибка, чтобы проанализировать ее причину.

3. Анализ кода. Используя отладчик или другие инструменты, необходимо проанализировать код и выявить места, где возникает ошибка.

4. Исправление ошибки. После выявления места ошибки необходимо внести изменения в код, чтобы исправить проблему.

5. Тестирование. После внесения изменений необходимо провести тестирование, чтобы убедиться, что проблема была устранена и другие части программы не были повреждены.

В процессе дебаггинга может использоваться также методика "разделяй и властвуй", когда код разбивается на отдельные части, которые тестируются и отлаживаются по отдельности.

После проведения дебаггинга может быть создан отчет, в котором будут отражены результаты анализа ошибок и рекомендации по их устранению.

  \end{document}